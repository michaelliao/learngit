## 分支管理

创建dev分支，然后切换到dev分支：
git checkout -b dev

git checkout命令加上-b参数表示创建并切换，相当于以下两条命令
git branch dev
git checkout dev

git branch 命令列出所有分支，当前分支前面会标一个*号

git merge dev   把dev分支的工作成果合并到当前分支上

git branch -d dev 删除dev分支


### 解决冲突
git checkout -b feature1
修改readme.txt最后一行，改为：
Creating a new branch is quick AND simple

在feature1分支上提交：
git add readme.txt
git commit -m "AND simple"

切换到master分支：
git checkout master

在master分支上把readme.txt文件的最后一行改为：
Creating a new branch is quick & simple.

提交：
git add readme.txt
git commit -m "& simple"

合并，产生冲突了
git merge feature1

Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.


git status也可以告诉我们冲突的文件

cat readme.txt  查看readme.txt

Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存
Creating a new branch is quick and simple.

再提交：
git add readme.txt
git commit -m "conflict fixed"

最后，删除feature1分支
git branch -d feature1


当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。

解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。

用git log --graph命令可以看到分支合并图。


### 分支管理
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

例：
创建并切换dev分支
git checkout -b dev

修改readme.txt文件，并提交一个新的commit：
git add readme.txt
git commit -m "add merge"

切换回master：
git checkout master

准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward
因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
git merge --no-ff -m "merge with no-ff" dev

合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，
而fast forward合并就看不出来曾经做过合并。

在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
那在哪干活呢？
干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
所以，团队合作的分支看起来就像这样：






### Bug分支
每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，
当前正在dev上进行的工作还没有提交，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
git stash

创建分支来修复bug
首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：
git checkout master
git checkout -b issue-101

修复好bug后，切换到master分支，并完成合并，最后删除issue-101分支
git checkout master
git merge --no-ff -m "merged bug fix 101" issue-101

回到dev分支干活
git checkout dev
git stash list  可以查看存储的工作现场

恢复之前存储的工作现场，有两个方法：
（1）
git stash apply         恢复，但是恢复后，stash内容并不删除，你需要用
git stash drop          删除stash内容
（2）
git stash pop    恢复的同时把stash内容也删了


再用git stash list查看，就看不到任何stash内容了：
git stash list

你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
git stash apply stash@{0}

Bug分支
阅读: 349105
软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：

$ git status
On branch dev
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   hello.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   readme.txt
并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？

幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：

$ git stash
Saved working directory and index state WIP on dev: f52c633 add merge
现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。

首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：

$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use "git push" to publish your local commits)

$ git checkout -b issue-101
Switched to a new branch 'issue-101'
现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：

$ git add readme.txt
$ git commit -m "fix bug 101"
[issue-101 4c805e2] fix bug 101
1 file changed, 1 insertion(+), 1 deletion(-)
修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：

$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use "git push" to publish your local commits)

$ git merge --no-ff -m "merged bug fix 101" issue-101
Merge made by the 'recursive' strategy.
readme.txt | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)
太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！

$ git checkout dev
Switched to branch 'dev'

$ git status
On branch dev
nothing to commit, working tree clean
工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：

$ git stash list
stash@{0}: WIP on dev: f52c633 add merge
工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：

一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；

另一种方式是用git stash pop，恢复的同时把stash内容也删了：

$ git stash pop
On branch dev
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   hello.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   readme.txt

Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)
再用git stash list查看，就看不到任何stash内容了：

$ git stash list
你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：

$ git stash apply stash@{0}

小结
修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；
当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。


### Feature分支
添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，
所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。

git checkout -b feature-vulcan
git add vulcan.py
git status
git commit -m "add feature vulcan"
git checkout dev    切回dev
git branch -d feature-vulcan        
销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数
强行删除：
git branch -D feature-vulcan

小结
开发一个新feature，最好新建一个分支；
如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。

### 多人协作
当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin
查看远程库的信息:
git remote

查看远程库的信息,显示更详细的信息
git remote -v


#### 推送分支
推送分支，就是把该分支上的所有本地提交推送到远程库。
推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：
git push origin master

如果要推送其他分支，比如dev，就改成
git push origin dev

并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？
(1)master分支是主分支，因此要时刻与远程同步
(2)dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步
(3)bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug
(4)feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

#### 抓取分支
当你从远程库clone时，默认情况下，你只能看到本地的master分支。不信可以用git branch命令看看：
git branch

你要在dev分支上开发，就必须创建远程origin的dev分支到本地，用这个命令创建本地dev分支：
git checkout -b dev origin/dev

现在你可以在dev上继续修改，然后，时不时地把dev分支push到远程
git add env.txt
git commit -m "add env"
git push origin dev

你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，
现在你推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，
解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：
$ git pull

There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> dev

git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：
$ git branch --set-upstream-to=origin/dev dev    
Branch 'dev' set up to track remote branch 'dev' from 'origin'.

再pull:
$ git pull
Auto-merging env.txt
CONFLICT (add/add): Merge conflict in env.txt
Automatic merge failed; fix conflicts and then commit the result.

这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。
解决后，提交，再push：
$ git commit -m "fix env conflict"
[dev 57c53ab] fix env conflict

$ git push origin dev
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   7a5e5dd..57c53ab  dev -> dev


#### 多人协作的工作模式通常是这样：   
(1)首先，可以试图用git push origin <branch-name>推送自己的修改；
(2)如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
(3)如果合并有冲突，则解决冲突，并在本地提交；
(3)没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！

如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，
用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。



















