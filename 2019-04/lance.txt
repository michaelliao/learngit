初始化一个Git仓库，使用git init命令。
添加文件到Git仓库，分两步：
使用命令git add <file>，注意，可反复多次使用，添加多个文件；
使用命令git commit -m <message>，完成。


要随时掌握工作区的状态，使用git status命令。
如果git status告诉你有文件被修改过，用git diff可以查看修改内容。


HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。


场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。
场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。


要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；
关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；
分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！

要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。

Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>


当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。
用git log --graph命令可以看到分支合并图。

分支策略
在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
所以，团队合作的分支看起来就像这样：

小结
Git分支十分强大，在团队开发中应该充分应用。
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。

一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
另一种方式是用git stash pop，恢复的同时把stash内容也删了：
修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；
当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。

开发一个新feature，最好新建一个分支；
如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。


当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。
要查看远程库的信息，用git remote：

或者，用git remote -v显示更详细的信息：


推送分支
推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：
$ git push origin master

如果要推送其他分支，比如dev，就改成：
$ git push origin dev

但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？
master分支是主分支，因此要时刻与远程同步；
dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。
总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！



因此，多人协作的工作模式通常是这样：
首先，可以试图用git push origin <branch-name>推送自己的修改；
如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
如果合并有冲突，则解决冲突，并在本地提交；
没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！
如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。
这就是多人协作的工作模式，一旦熟悉了，就非常简单。


查看远程库信息，使用git remote -v；
本地新建的分支如果不推送到远程，对其他人就是不可见的；
从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。


rebase操作可以把本地未push的分叉提交历史整理成直线；
rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。




注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。
标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：
命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；
命令git tag -a <tagname> -m "blablabla..."可以指定标签信息；
命令git tag可以查看所有标签。	


如果标签打错了，也可以删除：
git tag -d v0.1
因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。
如果要推送某个标签到远程，使用命令git push origin <tagname>


命令git push origin <tagname>可以推送一个本地标签；
命令git push origin --tags可以推送全部未推送过的本地标签；
命令git tag -d <tagname>可以删除一个本地标签；
命令git push origin :refs/tags/<tagname>可以删除一个远程标签。


在GitHub上，可以任意Fork开源仓库；
自己拥有Fork后的仓库的读写权限；
可以推送pull request给官方仓库来贡献代码。





git is a distributed version control system.
learn git from now.
practice makes perfect.
git init // 将当前目录定义为git库
cd //定义目录
pwd //查询当前目录
git add //把文件保存到stage区
git commit -m "version.name" //把stage区里的内容全部提交到master
git diff //查看工作区与stage区的区别
git status //查看当前状态

git log//查询提交的版本记录
git reset --hard HEAD^ //回溯上一个版本
git reset --hard HEAD~10 //回溯到前10的版本
git reset --hard commit_id //根据提交的id，回溯到某个版本

cat file.txt //查看文件
git reflog //显示记录的每一次命令
git checkout -- file //丢弃工作区文件的修改，让这个文件回到最近一次git commit或git add时的状态
git reset HEAD file.name //把暂存stage区的修改撤销掉（unstage）,重新放回工作区
rm或git rm //把文件从stage区和工作区里删除，只能从版本库里回退最近提交版本的文件
git rm --cached file_path //把文件从暂存区删除，但本地需要.

git remote add origin git@github.com:inorimoe/git.git
//把本地版本库关联到github远程库
git remote add origin git@server-name:path/repo-name.git
//要关联一个远程库，使用命令
git push -u origin master //第一次推送master分支，-u参数不懂
git clone git@github.com:account/远程库名.git //从远程库克隆

git branch //查看分支	
git branch <name> //创建分支
git checkout <name> //切换分支
git checkout -b <name> //创建+切换分支
git merge <name> //合并某分支到当前分支
git branch -d <name> //删除分支
git log --graph //调出提交日志，显示分支合并路线图
git log --graph --pretty=oneline --abbrev-commit //效果类似上一条指令，显示精简信息
git merge --no-ff -m "xxx" dev
//创建一个新的commit存放合并的文件，-m参数描述提交的commit("xxx")信息，注意--no-ff参数，即强制禁用Fast Forwad模式(通过移动HEAD指针来快速合并分支主干的内容)

git stash //把当前工作区的内容储存起来,储存到stash@{n}
//注意：stash的坑：可理解为：工作区和暂存区是一个公开的工作台，任何分支都会用到，并能看到工作台上最新的内容，只要在工作区、暂存区的改动未能够提交到某一个版本库（分支/）中，那么在任何一个分支下都可以看得到这个工作区、暂存区的最新实时改动。
//使用git stash就可以将工作区和暂存区的修改藏匿起来，使整个工作台看起来都是干净的(可能会回退到最近commited的状态）。
//所以要初始化整个工作台,之后在干净的工作台上可以做另外一件紧急事件与藏匿起来的内容是完全独立的。
//把文件stash后，使用恢复指令都会恢复到工作区，注意status,并且及时add
git stash list //查看储存到哪个stash@{n}
git stash apply //恢复到工作区，恢复后，stash内容并不删除
git stash drop //彻底删除
git stash pop //恢复的同时把stash也删除了
git stash apply stash@{0} //恢复指定的stash

git branch -D <name> //强行删除某一个没有被合并过的分支，参数是大写D

git remote -v //查看远程库的详细信息，去掉-v，显示精简信息
git push origin master //把该master分支上的所有本地提交推送到远程库
git push origin branch-name //效果同上，推送某个分支到远程库
git pull //取回远程主机某个分支的更新，再与本地的指定分支合并，可使用下一个指令建立分支关联
git branch --set-upstream branch-name origin/branch-name
//建立本地分支和远程分支的关联
git checkout -b branch-name origin/branch-name //在本地创建和远程分支对应的分支，本地和远程分支的名称最好一样；
git push origin :br //(origin 后面有空格)，git 删除远程分支
标签
git tag <tagname> <commit_id> //用于新建一个标签，默认为HEAD,也可以用于指定的一个commit_id
git tag -a <tagname> -m "blablabla..." //可以指定标签信息；
git tag //可以查看所有标签
git tag -d <tagname> //删除本地标签。
git push origin <tagname> //推送某个标签到远程
git push origin --tags //一次性推送全部尚未推送到远程的本地标签
git push origin :refs/tags/<tagname> //可以删除一个远程标签。
